#!/usr/bin/perl

=head2 SYNOPSIS
 
 backup_reporter.pl needs to be called with no parameters
 
 The script needs several variables pre-configured
  
   * Location of backup root directory (also used to find receipts)
   * Location of original files (to track removed files)
   * Location of the file with list of projects/their respective sizes
   * prefix that this script will use [backup_]
   * Optional image file generated by the same script that generates file with sizes

 Will produce an HTML report that would list projects along with the status of 
 different backup steps. Ideally, should be run as a cron job so that results
 are updated regularly

=head2 FORMAT
 
 status hash that hold all statuses is structured as this:
 status{PROJ1} -> {indexed  => 3,
                   encrypted=> 3,
                   checked  => 2,
                   files    => 3245,
                   gbsize   => 1000,
                   source   => "Present",
                   tape     => ""}

 HTML-report producing code will translate this into meaningful messages
                   
=cut

use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;
use IO::File;
use POSIX qw(strftime);
use constant DEBUG=>0;
use CGI qw(:standard escape form start_table end_table);
my @states = ("Not started","Pending","Possible Problem","Complete");
my @colors = ("grey","yellow","red","green");

my $TIMELIMIT = 259200; # 3 days
my($backup_root,$size_file,$size_graph,$html_path,$source_root);
my $prefix  = "backup_"; # Hard-coded for now
my $result  = GetOptions ('backup-root=s' => \$backup_root,
                          'source-root=s' => \$source_root,
                          'size-file=s'   => \$size_file,
                          'size-graph=s'  => \$size_graph,
                          'html-path=s'   => \$html_path);

# Find all projects using size_file, if there's image build graphical part of the report
if (!$backup_root || !$size_file || !$html_path) {die "Run this script as backup_reporter.pl --backup-root [DIR] --source-root [DIR, optional] --size-file [FILE] --size-graph [PNG, optional] --html-path [out.html]";}

# Using backup_root find receipts and all active directories, initialize hash
if ($backup_root!~m!/$!){$backup_root.="/";}
if ($source_root && (!-e $source_root || !-d $source_root)){$source_root = undef;}elsif($source_root=~m!/$!){chop($source_root);}

my %status = ();

# Load data from size file, initialize hash
# ==========================================
open(SIZE, "<$size_file") or die "Couldn't read from size file [$size_file]";
while (<SIZE>) {
 chomp;
 # FORMAT: Project\tFiles\tGigabytes
 # as in:AdrenocorticalCancer    23680   806
 my @temp = split("\t");
 if (!$temp[2] || $temp[2]!~/^\d+$/){next;}
 
 $status{$temp[0]} = {indexed  => 0,
                      encrypted=> 0,
                      checked  => 0,
                      files    => $temp[1],
                      gbsize   => $temp[2],
                      source   => "",
                      tape     => ""};
}
close SIZE;


my $receipt_dir = $backup_root."receipts";
# Load receipt data from a receipt file, if available
# ===================================================
print STDERR scalar(keys %status)." Records found in size file\n" if DEBUG;
foreach my $p (keys %status) {
 &find_receipts($receipt_dir,$p);
 &run_checks($p);
 &find_deleted($source_root,$p) if $source_root;
}
#print STDERR Dumper(%status) if DEBUG;
# Assume that all steps are complete for those with receipt and check the pipeline's status only for those without receipts
# (Recepts should be named using backup directories' names

&print_HTML($html_path);


exit;

# Check status
# ===================================================
sub find_receipts {
 my $r_dir   = shift @_;
 my $project = shift @_;

 my $rfile = join("/",($r_dir,$project));
 if (-e $rfile && -s $rfile) {
  my $record = `cat $rfile`;
  chomp($record);
  print STDERR "Found tape IDs [$record] for [$project]\n" if DEBUG;
  if ($record=~/^\d+(\,*\d*)*$/) {
      $status{$project}->{tape} = $record;
      $status{$project}->{indexed}   = 3;
      $status{$project}->{encrypted} = 3;
      $status{$project}->{checked}   = 3;
  }
 }
}

# If we have source-root, check for deleted projects
# ==================================================
sub find_deleted {
 my $s_dir = shift @_;
 my $project = shift @_;

 my $proj_dir = join("/",($s_dir,$project));
 if (-e $proj_dir && -d $proj_dir) {
   print STDERR "Found original data for [$project] on file system\n" if DEBUG;
   $status{$project}->{source} = "Present";
 } else {
   print STDERR "Original data [$project] were removed from file system\n" if DEBUG;
   $status{$project}->{source} = "Removed from Filesystem";
 }
}

# For all check_ subs the argument is Project's name
# At this point we need to make sure that Project's root dir exists
# =================================================================
sub run_checks {
 my $project = shift @_;
 my $proot   = $backup_root.$prefix.$project;
 if ($status{$project}->{tape}){
   print STDERR "Project $project is on tape, skipping checks...\n" if DEBUG;
   return;
  }

 print STDERR "Will run checks on [$proot]\n" if DEBUG;
 if (!-e $proot || !-d $proot){return;}

 opendir(DIR, $proot) or die "Couldn't read from Project's dir [$proot]";
 my @subdirs = readdir DIR;
 closedir(DIR);

 foreach my $d (sort @subdirs) {
  my $nextdir = join("/",($proot,$d));
  if (-e $nextdir && $d eq "APPROVED_TO_WRITE") {
     print STDERR "Project $project seems OK to go to TAPE\n" if DEBUG;
     $status{$project}->{indexed}   = 3;
     $status{$project}->{encrypted} = 3;
     $status{$project}->{checked}   = 3;
     $status{$project}->{tape}      = "*** OK to Go ***";
     return;
  }
  
  if (!-e $nextdir || !-d $nextdir) {next;}
  # skip dir if there's no data for it in size file
  
  # Check indexer
  my $stat = 0;

  if ($d =~/index/) { 
  
   my $idir = $nextdir;
   opendir(IDX, $idir) or die "Couldn't read from directory [$idir]";
   my @i_files = readdir(IDX);
   closedir(IDX);

   foreach my $ifile (@i_files) {
     if ($ifile eq "Files.md5.RF.completed") {
       $stat = 3;
       last;
     } elsif ($ifile eq "Files" && $stat == 0) {
       $stat = 1;
       my $filePath = join("/",($idir,$ifile));
       my $lmod = (stat($filePath))[9];

       my $now = time;
       print STDERR "Comparing $now and $lmod\n" if DEBUG;
       if ($now - $lmod > $TIMELIMIT) {
         $stat = 2;
       }
     }   
    }
    $status{$project}->{indexed} = $stat;
    $stat = 0;
   # Check encrypter
   } elsif ($d =~/encrypted/) {
     my $edir = $nextdir;
     my $e_files = `find $edir -type f | wc -l`;
     my $i_files = `cat $proot/index/Files | wc -l`;
     chomp($e_files);
     chomp($i_files);
     print STDERR "Comparing indexed [$i_files] vs [$e_files] encrypted files\n" if DEBUG;
     if (!$i_files || !$e_files || $i_files != $e_files) {
         $stat = 1;
     } else {
         $status{$project}->{files} = $i_files;
         $stat = 3;
     }
     $status{$project}->{encrypted} = $stat;
     $stat = 0;
   # Check checker (at this point we know that something is possibly wrong
   } elsif ($d =~/scripts/) {
     my $sdir = $nextdir;
     opendir(SCR, $sdir) or die "Couldn't read from directory [$sdir]";
     my @s_files = readdir(SCR);
     foreach my $sfile(@s_files) {
       if ($sfile =~/^CHK.*error.*/) {
         $stat = 2;
         last;
       } elsif ($sfile eq "checker_instruction.tab" && $stat == 0) {
         $stat = 1;
       } 
     }
     $status{$project}->{checked} = $stat;
     $stat = 0;
   }
}
}


# Printing HTML
sub print_HTML {
my @head_titles = $source_root ? ("Project","Files","Size, GB","Indexed","Encrypted","Verified","Tape ID(s)","Original Files")
                               : ("Project","Files","Size, GB","Indexed","Encrypted","Verified","Tape ID(s)");
my @head_tds = ();
map{push(@head_tds, (td(h4($_))))} @head_titles;

my $headrow = Tr({-align=>'LEFT', -valign=>'BOTTOM', -bgcolor=>"lightgray"},
                  @head_tds 
                  );
  my $output = shift @_;
  my $outdir = $output;
  $outdir =~s!/$!!;
  $outdir = "./";
  my $tmppath = $outdir."tmp.html_$$";

  my $html = new IO::File(">$tmppath") or die "Couldn't write into [$output]\n";

  print $html start_html(-title=>'Tape Backup Report',
                         -author=>'pruzanov@oicr.on.ca',
                         -meta=>{'keywords'=>'tape EOL backup tracking report',
                                 'copyright'=>'&copy; 2015 OICR'},
                         -script=>{'src'=>'sorttable.js'},
                         -BGCOLOR=>'white');

 print $html h2("Project EOL Tape Backup Tracking");
 
 my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
 my $currentTime = strftime "%Y-%m-%e %T.00", $sec,$min,$hour,$mday,$mon,$year;
 print $html h6("Last Updated: ".$currentTime);
 my @trs = ($headrow); # table rows

 map{push(@trs,&format_row($_,$status{$_}))} (sort keys %status);


 print $html table({-border=>"1",
                    -cellpadding=>"15",
                    -cellspacing=>"0",
                    -class=>"sortable"},
                    thead($headrow),
                    tbody(@trs));
   
  

 print $html end_html;
 $html->close;
 print STDERR "Moving $tmppath to $output\n" if DEBUG;
 `mv $tmppath $output && chmod +r $output`;
}

# small subroutine for formatting rows
sub format_row {
 my $project = shift;
 my $entry   = shift;
 
 $entry->{files}=~s/(\d{1,3}?)(?=(\d{3})+$)/$1,/g;
 $entry->{gbsize}=~s/(\d{1,3}?)(?=(\d{3})+$)/$1,/g;

 my @data_tds = (td($project),
                 td($entry->{files}),
                 td($entry->{gbsize}),
                 td({-bgcolor=>$colors[$entry->{indexed}]},$states[$entry->{indexed}]),
                 td({-bgcolor=>$colors[$entry->{encrypted}]},$states[$entry->{encrypted}]),
                 td({-bgcolor=>$colors[$entry->{checked}]},$states[$entry->{checked}]),
                 td(h5($entry->{tape})));
 if ($source_root){push @data_tds, td(h5($entry->{source}));} 
 return Tr({-align=>'LEFT', -valign=>'CENTER', -bgcolor=>"white"},
        @data_tds
        );

}

